/**
 * User Story Workflow - Phase 2 of Three-Phase Agile Workflow
 *
 * Generates formal user stories from refined requirements.
 * Focus: User story format, acceptance criteria, definition of done, story points
 */

import { proxyActivities, ApplicationFailure } from '@temporalio/workflow';
import type { WorkflowConfig } from '@devflow/common';
import { DEFAULT_WORKFLOW_CONFIG } from '@devflow/common';
import type * as activities from '@/activities';

// Proxy activities with 5-minute timeout
const {
  syncLinearTask,
  updateLinearTask,
  generateUserStory,
  appendUserStoryToLinearIssue,
} = proxyActivities<typeof activities>({
  startToCloseTimeout: '5 minutes',
  retry: {
    maximumAttempts: 3,
  },
});

export interface UserStoryWorkflowInput {
  taskId: string;
  projectId: string;
  config?: WorkflowConfig;
}

export interface UserStoryWorkflowResult {
  success: boolean;
  phase: 'user_story';
  message: string;
  userStory?: any;
}

/**
 * Extract refinement from Linear issue description
 * TODO: Move to workflow helpers in Task 17
 */
function extractRefinementFromDescription(description: string): any {
  // Simple extraction for now
  // The refinement is appended as markdown in the format:
  // # Backlog Refinement
  // > Generated by DevFlow - Phase 1: Refinement
  // ...

  const refinementMatch = description.match(/# Backlog Refinement[\s\S]*?(?=\n# |$)/);
  if (!refinementMatch) {
    // If no refinement found, return minimal refinement object
    return {
      taskType: 'feature',
      businessContext: description,
      objectives: [],
      preliminaryAcceptanceCriteria: [],
      complexityEstimate: 'M',
    };
  }

  const refinementText = refinementMatch[0];

  // Extract task type
  const taskTypeMatch = refinementText.match(/\*\*Type:\*\* [^\s]+ (\w+)/);
  const taskType = taskTypeMatch ? taskTypeMatch[1].toLowerCase() : 'feature';

  // Extract business context
  const contextMatch = refinementText.match(/## Business Context\n\n([\s\S]*?)(?=\n## |$)/);
  const businessContext = contextMatch ? contextMatch[1].trim() : '';

  // Extract objectives
  const objectivesMatch = refinementText.match(/## Objectives\n\n([\s\S]*?)(?=\n## |$)/);
  const objectives = objectivesMatch
    ? objectivesMatch[1]
        .split('\n')
        .filter((line) => line.match(/^\d+\./))
        .map((line) => line.replace(/^\d+\.\s*/, '').trim())
    : [];

  // Extract preliminary acceptance criteria
  const criteriaMatch = refinementText.match(/## Preliminary Acceptance Criteria\n\n([\s\S]*?)(?=\n## |$)/);
  const preliminaryAcceptanceCriteria = criteriaMatch
    ? criteriaMatch[1]
        .split('\n')
        .filter((line) => line.match(/^\d+\./))
        .map((line) => line.replace(/^\d+\.\s*/, '').trim())
    : [];

  // Extract complexity estimate
  const complexityMatch = refinementText.match(/\*\*(XS|S|M|L|XL)\*\*/);
  const complexityEstimate = complexityMatch ? complexityMatch[1] : 'M';

  return {
    taskType,
    businessContext,
    objectives,
    preliminaryAcceptanceCriteria,
    complexityEstimate,
  };
}

/**
 * User Story Workflow
 * Phase 2: Transform refined requirements into formal user story
 */
export async function userStoryWorkflow(
  input: UserStoryWorkflowInput
): Promise<UserStoryWorkflowResult> {
  const config = input.config || DEFAULT_WORKFLOW_CONFIG;
  const LINEAR_STATUSES = config.linear.statuses;

  try {
    // Step 1: Sync task from Linear
    const task = await syncLinearTask({
      taskId: input.taskId,
      projectId: input.projectId,
    });

    // Step 2: Update status to UserStory In Progress
    await updateLinearTask({
      projectId: input.projectId,
      linearId: task.linearId,
      updates: { status: LINEAR_STATUSES.userStoryInProgress },
    });

    // Step 3: Extract refinement from Linear description
    const refinement = extractRefinementFromDescription(task.description);

    // Step 4: Generate user story
    const result = await generateUserStory({
      task: {
        title: task.title,
        description: task.description,
        priority: task.priority,
      },
      refinement,
      projectId: input.projectId,
    });

    // Step 5: Append user story to Linear issue
    await appendUserStoryToLinearIssue({
      projectId: input.projectId,
      linearId: task.linearId,
      userStory: result.userStory,
      multiLLM: result.multiLLM,
    });

    // Step 6: Update status to UserStory Ready
    await updateLinearTask({
      projectId: input.projectId,
      linearId: task.linearId,
      updates: { status: LINEAR_STATUSES.userStoryReady },
    });

    return {
      success: true,
      phase: 'user_story',
      message: `User story generated for task ${task.identifier}`,
      userStory: result.userStory,
    };
  } catch (error) {
    // Update status to UserStory Failed
    try {
      const task = await syncLinearTask({
        taskId: input.taskId,
        projectId: input.projectId,
      });

      await updateLinearTask({
        projectId: input.projectId,
        linearId: task.linearId,
        updates: { status: LINEAR_STATUSES.userStoryFailed },
      });
    } catch (updateError) {
      // Log but don't throw - original error is more important
      console.error('Failed to update status to userStoryFailed:', updateError);
    }

    // Throw original error
    throw ApplicationFailure.create({
      message: `User story workflow failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      type: 'UserStoryWorkflowFailure',
      cause: error instanceof Error ? error : undefined,
    });
  }
}
