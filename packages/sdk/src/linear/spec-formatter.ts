/**
 * Spec Formatter for Linear - Formats technical specifications as markdown
 */

import {
  SpecGenerationOutput,
  RefinementOutput,
  UserStoryGenerationOutput,
  TechnicalPlanGenerationOutput,
  CouncilSummary,
} from '@devflow/common';

/**
 * Format a technical specification as markdown for Linear
 */
export function formatSpecAsMarkdown(spec: SpecGenerationOutput): string {
  const sections: string[] = [];

  // Header
  sections.push('# Technical Specification');
  sections.push('');
  sections.push('> Generated by DevFlow');
  sections.push('');

  // Architecture
  if (spec.architecture && spec.architecture.length > 0) {
    sections.push('## Architecture Decisions');
    sections.push('');
    spec.architecture.forEach((decision, i) => {
      sections.push(`${i + 1}. ${decision}`);
    });
    sections.push('');
  }

  // Implementation Steps
  if (spec.implementationSteps && spec.implementationSteps.length > 0) {
    sections.push('## Implementation Steps');
    sections.push('');
    spec.implementationSteps.forEach((step, i) => {
      sections.push(`${i + 1}. ${step}`);
    });
    sections.push('');
  }

  // Technical Decisions
  if (spec.technicalDecisions && spec.technicalDecisions.length > 0) {
    sections.push('## Technical Decisions');
    sections.push('');
    spec.technicalDecisions.forEach((decision) => {
      sections.push(`- ${decision}`);
    });
    sections.push('');
  }

  // Dependencies
  if (spec.dependencies && spec.dependencies.length > 0) {
    sections.push('## Dependencies');
    sections.push('');
    spec.dependencies.forEach((dep) => {
      sections.push(`- ${dep}`);
    });
    sections.push('');
  }

  // Testing Strategy
  if (spec.testingStrategy) {
    sections.push('## Testing Strategy');
    sections.push('');
    sections.push(spec.testingStrategy);
    sections.push('');
  }

  // Risks
  if (spec.risks && spec.risks.length > 0) {
    sections.push('## Risks & Considerations');
    sections.push('');
    spec.risks.forEach((risk) => {
      sections.push(`- âš ï¸ ${risk}`);
    });
    sections.push('');
  }

  // Estimated Time
  if (spec.estimatedTime) {
    sections.push('## Estimated Time');
    sections.push('');
    const hours = Math.floor(spec.estimatedTime / 60);
    const minutes = spec.estimatedTime % 60;
    if (hours > 0) {
      sections.push(`~${hours} hour${hours > 1 ? 's' : ''} ${minutes > 0 ? `${minutes} minutes` : ''}`);
    } else {
      sections.push(`~${minutes} minutes`);
    }
    sections.push('');
  }

  return sections.join('\n');
}

/**
 * Format a warning message for Linear (as a quote block)
 */
export function formatWarningMessage(message?: string): string {
  const warningText = message || 'This specification was generated by DevFlow. Please review before implementation.';
  return `> âš ï¸ **AI-Generated Content**\n>\n> ${warningText}`;
}

/**
 * Format spec with warning header
 */
export function formatSpecWithWarning(spec: SpecGenerationOutput, warningMessage?: string): string {
  const warning = formatWarningMessage(warningMessage);
  const specMarkdown = formatSpecAsMarkdown(spec);

  return `${warning}\n\n---\n\n${specMarkdown}`;
}

// ============================================
// Three-Phase Agile Workflow Formatters
// ============================================

/**
 * Format refinement output as markdown for Linear
 * Phase 1 of Three-Phase Agile Workflow
 */
export function formatRefinementAsMarkdown(refinement: RefinementOutput): string {
  const sections: string[] = [];

  // Header
  sections.push('# Backlog Refinement');
  sections.push('');
  sections.push('> Generated by DevFlow - Phase 1: Refinement');
  sections.push('');

  // Task Type Badge
  const typeEmojis = {
    feature: 'âœ¨',
    bug: 'ðŸ›',
    enhancement: 'ðŸ”§',
    chore: 'ðŸ§¹',
  };
  sections.push(`**Type:** ${typeEmojis[refinement.taskType]} ${refinement.taskType.toUpperCase()}`);
  sections.push('');

  // Business Context
  if (refinement.businessContext) {
    sections.push('## Business Context');
    sections.push('');
    sections.push(refinement.businessContext);
    sections.push('');
  }

  // Objectives
  if (refinement.objectives && refinement.objectives.length > 0) {
    sections.push('## Objectives');
    sections.push('');
    refinement.objectives.forEach((objective, i) => {
      sections.push(`${i + 1}. ${objective}`);
    });
    sections.push('');
  }

  // Preliminary Acceptance Criteria
  if (refinement.preliminaryAcceptanceCriteria && refinement.preliminaryAcceptanceCriteria.length > 0) {
    sections.push('## Preliminary Acceptance Criteria');
    sections.push('');
    refinement.preliminaryAcceptanceCriteria.forEach((criterion, i) => {
      sections.push(`${i + 1}. ${criterion}`);
    });
    sections.push('');
  }

  // Questions for Product Owner
  if (refinement.questionsForPO && refinement.questionsForPO.length > 0) {
    sections.push('## â“ Questions for Product Owner');
    sections.push('');
    refinement.questionsForPO.forEach((question) => {
      sections.push(`- ${question}`);
    });
    sections.push('');
  }

  // Suggested Split
  if (refinement.suggestedSplit) {
    sections.push('## ðŸ”€ Suggested Split');
    sections.push('');
    sections.push(`**Reason:** ${refinement.suggestedSplit.reason}`);
    sections.push('');
    sections.push('**Proposed Stories:**');
    sections.push('');

    refinement.suggestedSplit.proposedStories.forEach((story, i) => {
      sections.push(`### ${i + 1}. ${story.title}`);
      sections.push('');
      sections.push(story.description);
      sections.push('');

      // Dependencies
      if (story.dependencies && story.dependencies.length > 0) {
        sections.push('**Dependencies:**');
        story.dependencies.forEach((depIndex) => {
          const depTitle =
            refinement.suggestedSplit!.proposedStories[depIndex]?.title || `Subtask ${depIndex + 1}`;
          sections.push(`- Depends on: ${depTitle}`);
        });
        sections.push('');
      }

      // Acceptance Criteria
      if (story.acceptanceCriteria && story.acceptanceCriteria.length > 0) {
        sections.push('**Acceptance Criteria:**');
        story.acceptanceCriteria.forEach((criterion, idx) => {
          sections.push(`${idx + 1}. ${criterion}`);
        });
        sections.push('');
      }
    });
    sections.push('');
  }

  // Complexity Estimate
  const sizeEmojis = {
    XS: 'âšª',
    S: 'ðŸŸ¢',
    M: 'ðŸŸ¡',
    L: 'ðŸŸ ',
    XL: 'ðŸ”´',
  };
  sections.push('## Complexity Estimate');
  sections.push('');
  sections.push(`${sizeEmojis[refinement.complexityEstimate]} **${refinement.complexityEstimate}** (T-shirt sizing)`);
  sections.push('');

  return sections.join('\n');
}

/**
 * Format user story output as markdown for Linear
 * Phase 2 of Three-Phase Agile Workflow
 */
export function formatUserStoryAsMarkdown(story: UserStoryGenerationOutput): string {
  const sections: string[] = [];

  // Header
  sections.push('# User Story');
  sections.push('');
  sections.push('> Generated by DevFlow - Phase 2: User Story');
  sections.push('');

  // User Story Format
  sections.push('## Story');
  sections.push('');
  sections.push(`**As a** ${story.userStory.actor},`);
  sections.push(`**I want** ${story.userStory.goal},`);
  sections.push(`**So that** ${story.userStory.benefit}.`);
  sections.push('');

  // Business Value
  if (story.businessValue) {
    sections.push('## Business Value');
    sections.push('');
    sections.push(story.businessValue);
    sections.push('');
  }

  // Acceptance Criteria
  if (story.acceptanceCriteria && story.acceptanceCriteria.length > 0) {
    sections.push('## Acceptance Criteria');
    sections.push('');
    story.acceptanceCriteria.forEach((criterion, i) => {
      sections.push(`${i + 1}. ${criterion}`);
    });
    sections.push('');
  }

  // Definition of Done
  if (story.definitionOfDone && story.definitionOfDone.length > 0) {
    sections.push('## Definition of Done');
    sections.push('');
    story.definitionOfDone.forEach((item) => {
      sections.push(`- ${item}`);
    });
    sections.push('');
  }

  // Story Points
  sections.push('## Estimated Complexity');
  sections.push('');
  sections.push(`**Story Points:** ${story.storyPoints} (Fibonacci scale)`);
  sections.push('');

  return sections.join('\n');
}

/**
 * Format technical plan output as markdown for Linear
 * Phase 3 of Three-Phase Agile Workflow
 */
export function formatTechnicalPlanAsMarkdown(plan: TechnicalPlanGenerationOutput): string {
  const sections: string[] = [];

  // Header
  sections.push('# Technical Implementation Plan');
  sections.push('');
  sections.push('> Generated by DevFlow - Phase 3: Technical Plan');
  sections.push('');

  // Architecture Decisions
  if (plan.architecture && plan.architecture.length > 0) {
    sections.push('## Architecture Decisions');
    sections.push('');
    plan.architecture.forEach((decision, i) => {
      sections.push(`${i + 1}. ${decision}`);
    });
    sections.push('');
  }

  // Files Affected
  if (plan.filesAffected && plan.filesAffected.length > 0) {
    sections.push('## Files to Modify');
    sections.push('');
    plan.filesAffected.forEach((file) => {
      sections.push(`- \`${file}\``);
    });
    sections.push('');
  }

  // Implementation Steps
  if (plan.implementationSteps && plan.implementationSteps.length > 0) {
    sections.push('## Implementation Steps');
    sections.push('');
    plan.implementationSteps.forEach((step, i) => {
      sections.push(`${i + 1}. ${step}`);
    });
    sections.push('');
  }

  // Technical Decisions
  if (plan.technicalDecisions && plan.technicalDecisions.length > 0) {
    sections.push('## Technical Decisions');
    sections.push('');
    plan.technicalDecisions.forEach((decision) => {
      sections.push(`- ${decision}`);
    });
    sections.push('');
  }

  // Dependencies
  if (plan.dependencies && plan.dependencies.length > 0) {
    sections.push('## Dependencies');
    sections.push('');
    plan.dependencies.forEach((dep) => {
      sections.push(`- ${dep}`);
    });
    sections.push('');
  }

  // Testing Strategy
  if (plan.testingStrategy) {
    sections.push('## Testing Strategy');
    sections.push('');
    sections.push(plan.testingStrategy);
    sections.push('');
  }

  // Risks & Considerations
  if (plan.risks && plan.risks.length > 0) {
    sections.push('## Risks & Considerations');
    sections.push('');
    plan.risks.forEach((risk) => {
      sections.push(`- âš ï¸ ${risk}`);
    });
    sections.push('');
  }

  // Estimated Time
  if (plan.estimatedTime) {
    sections.push('## Estimated Time');
    sections.push('');
    const hours = Math.floor(plan.estimatedTime / 60);
    const minutes = plan.estimatedTime % 60;
    if (hours > 0) {
      sections.push(`~${hours}h ${minutes > 0 ? `${minutes}m` : ''}`);
    } else {
      sections.push(`~${minutes}m`);
    }
    sections.push('');
  }

  return sections.join('\n');
}

// ============================================
// LLM Council Formatter
// ============================================

/**
 * Format council deliberation summary as markdown for Linear
 * Appended to phase outputs when council mode is enabled
 */
export function formatCouncilSummaryAsMarkdown(summary: CouncilSummary): string {
  const sections: string[] = [];

  sections.push('---');
  sections.push('');
  sections.push('## LLM Council Deliberation');
  sections.push('');
  sections.push('> This output was generated through a 3-stage council deliberation process.');
  sections.push('');

  // Council composition
  sections.push('### Council Members');
  sections.push('');
  summary.councilModels.forEach((model) => {
    const shortName = model.split('/')[1] || model;
    sections.push(`- ${shortName}`);
  });
  const chairmanShort = summary.chairmanModel.split('/')[1] || summary.chairmanModel;
  sections.push(`- **Chairman:** ${chairmanShort}`);
  sections.push('');

  // Peer rankings table
  sections.push('### Peer Rankings');
  sections.push('');
  sections.push(summary.rankingSummary);
  sections.push('');

  // Agreement level with emoji
  const agreementEmoji =
    summary.agreementLevel === 'high'
      ? 'ðŸŸ¢'
      : summary.agreementLevel === 'medium'
        ? 'ðŸŸ¡'
        : 'ðŸ”´';
  sections.push(`**Agreement Level:** ${agreementEmoji} ${summary.agreementLevel.toUpperCase()}`);
  sections.push('');

  // Top ranked model
  const topRankedShort = summary.topRankedModel.split('/')[1] || summary.topRankedModel;
  sections.push(`**Top Ranked Model:** ${topRankedShort}`);
  sections.push('');

  // Synthesis note
  sections.push('### Synthesis');
  sections.push('');
  sections.push(summary.synthesisExplanation);
  sections.push('');

  return sections.join('\n');
}
